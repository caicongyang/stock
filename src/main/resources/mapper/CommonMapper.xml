<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.caicongyang.stock.mapper.CommonMapper">

    <!--为保证查询的字段值有序（存入与取出顺序一致）所以用LinkedHashMap-->
    <select id="queryTransactionStock" parameterType="java.util.HashMap" resultType="java.util.HashMap">
        SELECT
        s0.stock_code,
        s0.lastDayCompare AS last_day_compare,
        s1.mean_ratio AS mean_ratio
        FROM
        (
        SELECT
        t0.stock_code,
        t0.volume / t1.volume AS lastDayCompare
        FROM
        ( SELECT stock_code, volume, `close`, `open`, `high`, `low` FROM T_Stock WHERE trading_day = #{currentDate} ) AS t0 -- 最后一个交易日
        LEFT JOIN ( SELECT stock_code, volume,`close` FROM T_Stock WHERE trading_day = #{preDate} ) AS t1 ON t0.stock_code = t1.stock_code  -- 倒数第二个交易
        WHERE
        t0.volume / t1.volume > 2   -- 成交量是前一天的2倍
        AND t0.`close` >= t0.`open`  --  收盘价 大于开盘价
        AND  t0.`close`/ t1.`close` > 1
        ) s0
        JOIN (

        SELECT
        t0.volume / ( t1.mean ) AS mean_ratio,
        t0.stock_code
        FROM
        T_Stock AS t0
        LEFT JOIN (
        SELECT
        SUM( volume ) / 5 AS mean,  -- 获取最近4个工作日的成交量平均数
        stock_code
        FROM
        T_Stock
        WHERE
        trading_day IN ( SELECT trading_day FROM ( SELECT trading_day FROM T_Stock WHERE stock_code = '000001.XSHE' and trading_day <![CDATA[ <= ]]>  #{currentDate}  ORDER BY trading_day DESC LIMIT 6 ) AS t )
        and  trading_day != #{currentDate}
        -- 获取最近4个交易日的交易时间
        GROUP BY
        stock_code
        ) t1 ON t0.stock_code = t1.stock_code
        WHERE
        t0.trading_day = #{currentDate}
        AND t1.mean != 0  and t1.mean is not null
        AND t0.volume / t1.mean > 2  -- 当日的成交量是前4个平均数
        ) s1 ON s0.stock_code = s1.stock_code;
    </select>


    <!--获取倒数第二个交易日-->
    <select id="queryPreTradingDate" resultType="java.lang.String" parameterType="java.lang.String">
      SELECT trading_day FROM ( SELECT trading_day FROM T_Stock WHERE stock_code = '000001.XSHE' and trading_day <![CDATA[ <= ]]>   #{currentDate} ORDER BY trading_day DESC limit  1,1 ) AS t
    </select>

    <!--获取倒数第二个交易日-->
    <select id="queryTradingDate" resultType="java.lang.String" parameterType="java.lang.String">
        SELECT trading_day FROM ( SELECT trading_day FROM T_Stock WHERE stock_code = '000001.XSHE' and trading_day <![CDATA[ <= ]]>   #{currentDate} ORDER BY trading_day DESC limit  1 ) AS t
    </select>



    <!--获取倒数第一个交易日-->
    <select id="queryLastTradingDate" resultType="java.lang.String">
      SELECT trading_day FROM ( SELECT trading_day FROM T_Stock ORDER BY trading_day DESC limit  1,1 ) AS t
    </select>


    <select id="queryLastWeekTradingDate" resultType="java.lang.String">
      SELECT trading_day FROM ( SELECT trading_day FROM T_Stock_Week ORDER BY trading_day DESC limit  1,1 ) AS t
    </select>

    <select id="queryPreWeekTradingDate" resultType="java.lang.String">
       SELECT trading_day FROM ( SELECT trading_day FROM T_Stock_Week WHERE stock_code = '000001.XSHE' and trading_day <![CDATA[ <= ]]>   #{currentDate} ORDER BY trading_day DESC limit  1,1 ) AS t
    </select>


    <select id="getIntervalTransactionStockData" parameterType="java.util.HashMap" resultType="java.util.HashMap">
        SELECT
	t.counter,
	s.trading_day,
	s.stock_code,
	s.sw_l3,
	s.jq_l2,
	s.zjw,
    s.gain
FROM
	 ( SELECT count(*) AS counter, stock_code FROM T_transaction_stock where  trading_day BETWEEN #{startDate}  AND #{endDate}  GROUP BY stock_code HAVING counter > 1  ) as t  left join  T_transaction_stock s on t.stock_code =  s.stock_code
WHERE
	s.trading_day BETWEEN #{startDate}
	AND #{endDate}  and s.jq_l2 is not null  and s.sw_l3 is not null and s.zjw is not null
ORDER BY
	s.trading_day desc,
    t.counter desc,
	s.jq_l2 DESC,
	s.sw_l3 DESC,
	s.zjw DESC

    </select>


    <select id="getBreakthroughPlatform" parameterType="java.util.HashMap"
        resultType="java.util.HashMap">
	SELECT
	ts.stock_code,
	sh.interval_days,
	ts.last_day_compare,
	ts.mean_ratio,
	ts.jq_l2,
	ts.zjw,
	ts.sw_l3,
	ts.trading_day,
	ts.gain
FROM
	T_transaction_stock ts
	INNER JOIN T_Stock_Higher sh ON sh.stock_code = ts.stock_code
	AND sh.trading_day = ts.trading_day
WHERE
	ts.trading_day = #{currentDate}
	ORDER BY  ts.sw_l3 asc ,
	sh.interval_days desc

    </select>




    <select id="getVolumeGtYesterdayStock" parameterType="java.util.HashMap"
        resultType="java.util.HashMap">

    SELECT
    tf.volume / ts.volume AS counter,
    tf.stock_code
    FROM
    T_Stock_Half_Day tf
    LEFT JOIN (select stock_code, volume from T_Stock where  trading_day = #{preDate}) as ts  ON tf.stock_code = ts.stock_code
    WHERE
    tf.trading_day = #{currentDate}
    AND tf.volume / ts.volume > 1
    ORDER BY
    tf.volume / ts.volume DESC;
    </select>

</mapper>

